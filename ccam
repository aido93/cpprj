#!/bin/bash
set -e
# class method creator
# format: ccam [class_name] -[iou] -[fpo] name return type -a arguments [-t template types] [--for [i in a:b[:step]][[const]arg]][--switch params][--do/--while expr]
# if return type does not exist then script uses 'void'
# f - finished
# p - pure virtual
# o - override
args=("$@")
class_name=${args[0]}
access=${args[1]}
pure_virt=0
fin=0
override=0
if [ "${args[2]}" == "-f" ]; then
	fin=1
	method_name=${args[3]}
	args=("${args[@]:4}")
elif [ "${args[2]}" == "-p" ]; then
	pure_virt=1
	method_name=${args[3]}
	args=("${args[@]:4}")
elif [ "${args[2]}" == "-o" ]; then
	override=1
	method_name=${args[3]}
	args=("${args[@]:4}")
else
	method_name=${args[2]}
	args=("${args[@]:3}")
fi
flag_args=0
flag_template_args=0
flag_do=0
flag_while=0
flag_switch=0
flag_for=0
for opt in ${args[@]}; do
	if [ "$opt" != "-a" -a $flag_args -eq 0 ]; then
		ret_type="$ret_type $opt"
	elif [ "$opt" == "-a" ]; then
		flag_args=1
	elif [ "$opt" != "-t" -a $flag_template_args -eq 0 ]; then
		method_args="$method_args $opt"
	elif [ "$opt" == "-t" ]; then
		flag_template_args=1
	elif [ "$opt" == "--do" ]; then
		flag_do=1
	elif [ "$opt" == "--while" ]; then
		flag_while=1
	elif [ "$opt" == "--switch" ]; then
		flag_switch=1
	elif [ "$opt" == "--for" ]; then
		flag_for=1
	else
		temps[${#temps[*]}]="$opt"
	fi
done
method_args=`echo "$method_args" | cut -c 2-`
ret_type=`echo "$ret_type" | cut -c 2-`
if [ -z "$ret_type" ]; then
	ret_type="void"
elif [ "$ret_type" == "static" ]; then
	ret_type="static void"
elif [ "$ret_type" == "virtual" ]; then
	ret_type="virtual void"
fi
if [ -e "include" -a -e "src" ]; then
    if [ -e "include/$class_name.hpp" ]; then
		inc="include/$class_name.hpp"
		if [ -e "src/$class_name.cpp" ]; then
			src="src/$class_name.cpp"
		elif [ -e "include/${class_name}_impl.hpp" ]; then
			src="include/${class_name}_impl.hpp"
		else
			echo "Project tree is broken (source not found). Exit"
			exit
		fi
	else
	    echo "Project tree is broken (header not found). Exit"
		exit
	fi
	commas_count=`echo "$method_args" | grep -o , | wc -l`
	method="\\\n        /**\\\brief \n         * "
	if [ $commas_count -ne 0 ]; then
		for ((a = $commas_count; a>=0; a--)); do
			method="$method\\\param [in] - \n         * ";
		done
	fi
	if [ "$ret_type" != "void" -a "$ret_type" != "static void" -a "$ret_type" != "virtual void" ]; then
		method="$method\\\return \n        "
	fi
	method="$method */\n        $ret_type $method_name ($method_args)"
	is_virtual=`echo "$ret_type" | sed -n "/virtual/p"`
	if [ -n "$is_virtual" ]; then
		if [ $fin -eq 1 ]; then
			method="$method final"
		elif [ $override -eq 1 ]; then
			method="$method override"
		elif [ $pure_virt -eq 1 ]; then
			method="$method = 0"
		fi
	else
		echo "Error: not virtual function cannot be final or pure."
	fi
	method="$method;"
	if [ $flag_template_args -eq 0 -a $pure_virt -eq 0 ]; then
		method_src="$ret_type $class_name::$method_name ($method_args)\n{\n "
		ret_type=`echo "$ret_type" | sed "s/virtual //"`
		ret_type=`echo "$ret_type" | sed "s/static //"`
		if [ "$ret_type" != "void" ]; then
			method_src="$method_src    $ret_type result;\n"
		fi
		method_src="$method_src    "
		if [ "$ret_type" != "void" ]; then
			method_src="$method_src\n    return result;"
		fi
		method_src="$method_src\n}\n"
	elif [ $pure_virt -eq 0 ]; then
		if [ ${#temps[@]} -ne 0 ]; then 
		    separator1=", " # e.g. constructing regex, pray it does not contain %s                            
			regex="$( printf "${separator1}%s" "${temps[@]}" )" 
			temp1="${regex:${#separator1}}" # remove leading separator 
			separator2=", class " # e.g. constructing regex, pray it does not contain %s                      
			regex="$( printf "${separator2}%s" "${temps[@]}" )" 
			temp2="${regex:${#separator2}}" # remove leading separator 
			temp2=" class ${temp2}" 
		fi
		method_src="template<$temp2>\n$ret_type $class_name<$temp1>::$method_name ($method_args)\n{\n"
		ret_type=`echo "$ret_type" | sed "s/virtual //"`
		ret_type=`echo "$ret_type" | sed "s/static //"`
		if [ "$ret_type" != "void" ]; then
			method_src="$method_src    $ret_type result;\n"
		fi
		method_src="$method_src\t"
		if [ "$ret_type" != "void" ]; then
			method_src="$method_src\n    return result;"
		fi
		method_src="$method_src\n}\n"
	fi
	if [ "$access" == "-u" ]; then
		sed -i "/protected/i$method" $inc
	elif [ "$access" == "-o" ]; then
		sed -i "/private/i$method" $inc
	elif [ "$access" == "-i" ]; then
		sed -i "/}/i$method" $inc
	else
		echo "Wrong access type. Must be -i for pr(I)vate or -o for pr(O)tected or -u for p(U)blic. Exit"
		exit
	fi
	sed -i "$ a \\\n$method_src" $src
	sed -i '/./,/^$/!d' $src
else
	echo "You are not in the project directory. Exit"
fi
