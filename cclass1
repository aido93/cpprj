#!/bin/bash
# Class blank creator
# Syntax cclass1 <class_name> [-n <namespaces>][-t <types>][-u,-i,-vu<parent_classes>] [-pvd][-dd,-dm,-dc] [-vi/-vo][vars][-as,-ag] [-notest][-algo][-exc][-stdexc][-util] [-q] [-quinch <quoted includes list in header>][-binch <braced includes list in header>][-quincs <quoted includes list in src>][-bincs <braced includes list in src>]
# -algo   - add STL algorithm include
# -exc    - add STL exception include
# -stdexc - add STL stdexcept include
# -util   - add STL utility include
# -q      - Q_OBJECT
# STL types
containers=("vector","list","map","queue","deque","string","array","set","stack","forward_list","unordered_set","unordered_map")
memory=("auto_ptr","shared_ptr","weak_ptr","unique_ptr","auto_ptr_ref","default_delete",
	"allocator","allocator_arg","allocator_arg_t","allocator_traits",
	"enable_shared_from_this","owner_less","raw_storage_iterator","pointer_traits","pointer_safety")
chrono=("duration","time_point","system_clock","steady_clock","high_resolution_clock","treat_as_floating_point",
	"duration_values","hours","minutes","seconds","milliseconds")
complex=("complex")
functional=("function")
initializer_list=("initializer_list")
random=("random_device")
string=("string","wstring","basic_string","u16string","u32string")
tuple=("tuple","tuple_size","tuple_element")
valarray=("valarray","slice","gslice","slice_array","gslice_array","mask_array","indirect_array")
utility=("pair")
mutex=("mutex","recursive_mutex","timed_mutex","recursive_timed_mutex","unique_lock","lock_guard","once_flag")
thread=("thread")
future=("future","promise","packaged_task","shared_future","future_status","future_error","future_errc")
condition_variable=("condition_variable","condition_variable_any","cv_status")
atomic=("atomic","atomic_flag")

# Let's go!
set -e
args=("$@")
dd=0 #delete default constructor
dc=0 #delete copy constructor with operator=
dm=0 #delete move constructor with operator=
pvd=0 # pure virtual destructor flag
asi=0 #(A)dd public (S)etters to pr(I)vate variables
agi=0 #(A)dd public (G)etters to pr(I)vate variables
aso=0 #(A)dd public (S)etters to pr(O)tected variables
ago=0 #(A)dd public (G)etters to pr(O)tected variables

namespace_flag=0
declare -a namespaces #class namespace
template_flag=0
declare -a template_types
u=0
declare -a public_parents
i=0
declare -a private_parents
vu=0
declare -a virtual_public_parents
vi=0
priv_vars=""
vo=0
prot_vars=""

# include settings
quinch_flag=0
declare -a quinch
binch_flag=0
declare -a binch
quincs_flag=0
declare -a quincs
bincs_flag=0
declare -a bincs

# auxiliary settings
notest=0 #Disable test-file generation
algo=0
exc=0
stdexc=0
util=0
q=0
function zero_flags {
	i=0
	u=0
	vu=0
	namespace_flag=0
	template_flag=0
	vi=0
	vo=0
	quinch_flag=0
	binch_flag=0
	quincs_flag=0
	bincs_flag=0
}
class_name=${args[0]}
for opt in ${args[@]}; do
	if [ "$opt" == "-n" ]; then
		zero_flags
		namespace_flag=1
		continue
	fi
	if [ "$opt" == "-t" ]; then
		zero_flags
		template_flag=1
		continue
	fi
	if [ "$opt" == "-u" ]; then
		zero_flags
		u=1
		continue
	fi
	if [ "$opt" == "-i" ]; then
		zero_flags
		i=1
		continue
	fi
	if [ "$opt" == "-vu" ]; then
		zero_flags
		vu=1
		continue
	fi
	if [ "$opt" == "-pvd" ]; then
		zero_flags
		pvd=1
		continue
	fi
	if [ "$opt" == "-dd" ]; then 
		zero_flags
		dd=1
		continue
	fi
	if [ "$opt" == "-dm" ]; then 
		zero_flags
		dm=1
		continue
	fi
	if [ "$opt" == "-dc" ]; then 
		zero_flags
		dc=1
		continue
	fi
	if [ "$opt" == "-notest" ]; then 
		zero_flags
		notest=1
		continue
	fi
	if [ "$opt" == "-algo" ]; then 
		zero_flags
		algo=1
		continue
	fi
	if [ "$opt" == "-exc" ]; then 
		zero_flags
		exc=1
		continue
	fi
	if [ "$opt" == "-stdexc" ]; then 
		zero_flags
		stdexc=1
		continue
	fi
	if [ "$opt" == "-util" ]; then 
		zero_flags
		util=1
		continue
	fi
	if [ "$opt" == "-q" ]; then 
		zero_flags
		q=1
		continue
	fi
	if [ "$opt" == "-vi" ]; then 
		zero_flags
		vi=1
		continue
	fi
	if [ "$opt" == "-vo" ]; then 
		zero_flags
		vo=1
		continue
	fi
	if [ "$opt" == "-as" ]; then 
		if [ $vo -eq 1 ]; then
			aso=1
		elif [ $vi -eq 1 ]; then
			asi=1
		fi
		continue
	fi
	if [ "$opt" == "-ag" ]; then 
		if [ $vo -eq 1 ]; then
			ago=1
		elif [ $vi -eq 1 ]; then
			agi=1
		fi
		continue
	fi
	if [ "$opt" == "-quinch" ]; then 
		zero_flags
		quinch=1
		continue
	fi
	if [ "$opt" == "-quincs" ]; then 
		zero_flags
		quincs=1
		continue
	fi
	if [ "$opt" == "-binch" ]; then 
		zero_flags
		binch=1
		continue
	fi
	if [ "$opt" == "-bincs" ]; then 
		zero_flags
		bincs=1
		continue
	fi
	
	# Flags are parsed. Now we can determine their variables, names and types
	if [ $namespace_flag -eq 1 ]; then
		namespaces[${#namespaces[*]}]="$opt"
		continue
	fi
	
	if [ $template_flag -eq 1 ]; then
		template_types[${#template_types[*]}]="$opt"
		continue
	fi

	if [ $u -eq 1 ]; then
		public_parents[${#public_parents[*]}]="$opt"
		continue
	fi

	if [ $i -eq 1 ]; then
		private_parents[${#private_parents[*]}]="$opt"
		continue
	fi

	if [ $vu -eq 1 ]; then
		virtual_public_parents[${#virtual_public_parents[*]}]="$opt"
		continue
	fi

	if [ $quinch_flag -eq 1 ]; then
		quinch[${#quinch[*]}]="$opt"
		continue
	fi

	if [ $quincs_flag -eq 1 ]; then
		quincs[${#quincs[*]}]="$opt"
		continue
	fi

	if [ $binch_flag -eq 1 ]; then
		binch[${#binch[*]}]="$opt"
		continue
	fi

	if [ $bincs_flag -eq 1 ]; then
		bincs[${#bincs[*]}]="$opt"
		continue
	fi

	if [ $vo -eq 1 ]; then
		prot_vars="$prot_vars $opt"
		continue
	fi
	if [ $vi -eq 1 ]; then
		priv_vars="$priv_vars $opt"
		continue
	fi
done

echo "Debug: "
echo "Class name: $class_name"
if [ $q -eq 1 ]; then
echo "Class is Q_OBJECT"
fi
echo "Namespaces:"
printf '\t%s::' "${namespaces[@]}"
printf '\n'
echo "Private variables: "
echo -e "\t$priv_vars"
if [ $asi -eq 1 ]; then
echo -e "\tAdded public setters for private variables"
fi
if [ $agi -eq 1 ]; then
echo -e "\tAdded public getters for private variables"
fi
echo "Protected variables: "
echo -e "\t$prot_vars"
if [ $asi -eq 1 ]; then
echo -e "\tAdded public setters for protected variables"
fi
if [ $agi -eq 1 ]; then
echo -e "\tAdded public getters for protected variables"
fi
echo "Braced includes in header:"
printf '\t"%s"\n' "${binch[@]}"
echo "Braced includes in source:"
printf '\t"%s"\n' "${bincs[@]}"
echo "Quoted includes in header:"
printf '\t<%s>\n' "${quinch[@]}"
echo "Quoted includes in source:"
printf '\t<%s>\n' "${quincs[@]}"
echo "Private parents:"
printf '\t'
printf '%s ' "${private_parents[@]}"
printf '\n'
echo "Public parents:"
printf '\t'
printf '%s ' "${public_parents[@]}"
printf '\n'
echo "Virtual public parents:"
printf '\t'
printf '%s ' "${virtual_public_parents[@]}"
printf '\n'
echo "Template types:"
printf '\t'
printf '%s ' "${template_types[@]}"
printf '\n'
echo "Deleted constructors:"
deleted=""
if [ $dd -eq 1 ]; then
deleted="default, $deleted"
fi
if [ $dm -eq 1 ]; then
deleted="move, $deleted"
fi
if [ $dc -eq 1 ]; then
deleted="copy, $deleted"
fi
if [[ -n $deleted ]]; then
echo -e "\t$deleted"
else
echo -e "\tNo"
fi
if [ $pvd -eq 1 ]; then
echo "Added pure virtual destructor"
fi
if [ $notest -eq 1 ]; then
echo "Class does not have test suite"
else
echo "Class has test suite"
fi

echo "Added STL includes:"
stl=""
if [ $algo -eq 1 ]; then
stl="<algorithm> $stl"
fi
if [ $exc -eq 1 ]; then
stl="<exception> $stl"
fi
if [ $stdexc -eq 1 ]; then
stl="<stdexcept> $stl"
fi
if [ $util -eq 1 ]; then
stl="<util> $stl"
fi
echo -e "\t$stl"
